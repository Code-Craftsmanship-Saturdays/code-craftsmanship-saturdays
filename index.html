<html>
    <head>
        <link rel="stylesheet" href="reveal.css">
        <link rel="stylesheet" href="zenburn.css">
        <link rel="stylesheet" href="css/league.css">
    </head>
    <body>
        <div class="reveal">
            <div class="slides">
                <section>
					<h4>Code Craftsmanship Saturdays Third Session</h4>
					<p>Crafters today Jean-Marcel Belmont and Ryan Magoon</p>
					<p>First topics are Currying, Partial Application, and Memoization.</p>
					<p>Last topic will be Rx.js Observables and more</p>
				</section>
                <section>
					<section>
						<h4>So what does Currying even mean</h4>
						<p>Wikipedia Brief Definition</p>
						<p>In mathematics and computer science, currying is the technique of translating the evaluation of a function that takes multiple arguments (or a tuple of arguments) into evaluating a sequence of functions, each with a single argument</p>
					</section>
					<section>
						<h5>Meaning in programming concepts.</h5>
						<p>Converting a polyadic function (more than one argument) into a nested series of unary (one argument) functions is called currying</p>
						<p>Currying was named after Haskell Curry (1900 - 1982), who popularized the technique.</p>
						<p>Curry actually rediscovered the combinatory logic work of Moses Ilyich Sch√∂nfinkel (1889 - 1942) who was a Russian logician and mathematician who known for the invention of combinatory logic.</p>
					</section>
					<section>
						$\lambda$ (Lambda) Function. 
						<h3></h3>
						$$f = (x, y) \longrightarrow \frac{y}{x} $$
						<p>Arity of 2 here because the function has 2 inputs x and y</p>
						<p>Arity means the number of arguments a function accepts or takes in.</p>
					</section>
					<section>
						<h5>Example taken from Curry Article in Wikipedia</h5>
						<p>Here is a function of four arguments (Arity of Four):</p>
$$ f(x,y,z,w) $$
<p>Through series of curried actions the function maps curried values from one function to another</p>
$$ h_{x} = ((y,z,w) \mapsto f(x,y,z,w)) $$ 
$$ x\mapsto y\mapsto z\mapsto w\mapsto f(x,y,z,w) $$ 
$$ x\mapsto y\mapsto z\mapsto w\mapsto f(x,y,z,w) $$
<p>Through 4 function mappings the output is achieved.</p>
<p>Read https://en.wikipedia.org/wiki/Currying for more abstract details.</p>
					</section>
				</section>
                <section>
					<h5>Currying Code in action.</h5>
					<pre>
						<code data-trim class="javascript">
var helloWorldExampleOfCurry = function(message) {
	return function(name) {
		console.log(message + " my name is " + name);
	};
};

helloWorldExampleOfCurry("Hello there")("Marcel")
// outputs "Hello there my name is Marcel"
						</code>
					</pre>
					</section>
				</section>
				<section>
					<section>
						<h6>First Exercise of the day.</h6>
						<p>Write a curried function that outputs a message.</p>
						<p>name is Marcel and rank is Staff Sergeant</p>
					</section>
					<section>
						<h6>Here is a solution in es5</h6>
						<pre>
							<code data-trim class="javascript">
var curryWithES5 = function curryOneLevel(name) {
	return function(rank) {
		return 'name is ' + name + ' and rank is ' + rank;
	}
}

curryWithES5("Marcel")("Staff Sergeant")
// outputs "name is Marcel and rank is Staff Sergeant"
							</code>
						</pre>
					</section>
				</section>
				<section>
					<section>
						<h6>Second Exercise for Basic Currying.</h6>
						<p>Write a curried function that has an arity of three</p>
						$$ h_{x} = ((x,y,z) \mapsto f(x,y,z)) $$
						<p>This means you will need to return a function two times.</p>
						<p>This is because the function declaration has a closure for the first value</p>
						<p><strong>Correspondingly the function will need to invoked 3 times</strong></p>
						<p>Sample message should be of the form: </p>
						<p><strong>"state is North Carolina city is Raleigh zipCode is 27605"</strong></p>
					</section>
					<section>
						<h6>Solution to Second Exercise</h6>
						<pre>
							<code data-trim class="javascript">
// Solution in ES5
var deepCurryExample = function curryTwoLevels(state) {
    return function(city) {
        return function (zipCode) {
            return 'state is ' + state + ' city is ' 
		+ city + ' zipCode is ' + zipCode;
        }
    }
}
// Solution in ES6
const deepCurryWithES6 = state
	=> city
	=> zipCode 
	=> `state is ${state} city is ${city} zipCode is ${zipCode}`;
deepCurryExample("North Carolina")("Raleigh")("27605")
// "state is North Carolina city is Raleigh zipCode is 27605"
							</code>
						</pre>
					</section>
				</section>
				<section>
					<section>
						<h6>Advanced Currying Exercise</h6>
						<p>Write a Curried function that can compute the values of any number of values passed in.</p>
						<p>Suggestion 1: Write a separate function that sums up any number of values as input and returns sum back.</p>
						<p>Suggestion 2: Write another function that takes two parameters one being a callback function and another range of values.</p>
						<p>It should return another function that takes in another range of values.</p>
						<p>Then calls the callback function with range of values</p>
					</section>
					<section>
						<h6>Solution to Advanced Currying Exercise</h6>
						<p>Solution using ES5</p>
						<pre>
							<code data-trim class="javascript">
var counter = function() {
    var numbers = Array.prototype.slice.call(arguments);
    return numbers.reduce(function(prev, curr) {
        return prev + curr;
    }, 0);
}

var curryItUp = function(fn, firstNumbers) {
    let args;
    if (!Array.isArray(firstNumbers)) {
        args = Array.prototype.slice.call(arguments, 1);
    }
    return function(secondNumbers) {
        let otherArgs;
        if (!Array.isArray(secondNumbers)) {
            otherArgs = Array.prototype.slice.call(arguments);
            return fn.apply(this, Array.prototype.concat.call(args, otherArgs));
        }
        return fn.apply(this, Array.prototype.concat.call(firstNumbers, secondNumbers));
    }
}								
							</code>
						</pre>
					</section>
					<section>
						<h6>Solution using ES2015 syntax.</h6>
						<pre>
							<code data-trim class="javascript">
const counterES6 = (...numbers) => 
    numbers.reduce((prev, curr) => prev + curr, 0);

const curryItUpES6 = (fn, ...firstNumbers) => (...secondNumbers) => {
    return fn.apply(this, Array.prototype.concat.call(...firstNumbers, ...secondNumbers));
}								
							</code>
						</pre>
					</section>
				</section>
				<section>
					<section>
						<h6>Partial Application in JavaScript</h6>
						<p>Definition from Wikipedia</p>
						<p>In computer science, partial application (or partial function application)
						refers to the process of fixing a number of arguments to a function
						producing another function of smaller arity</p>
					</section>
					<section>
						<p>Partial application is thus the application of part of the arguments of a function, and getting in return a function that takes the remaining arguments</p>
					</section>
					<section>
						<p>Mathematical representation of partial application in action.</p>
						<p>$$ g(b,x) = f(2,b,x) = 2 * x + b $$</p>
						<p>Here the function g has an arity of 2 and then maps to a function f which partially applies the arguments x and b.</p>
					</section>
					<section>
						<p>Explanation in programmatic terms.</p>
						<p>The partial application function will receive a callback function and a value</p>
						<p>Then it can return another functioin that has another value but maps both values by applying one or more arguments.</p>
					</section>
					<section>
						<h6>The previous problem was in effect partial application in action</h6>
						<pre>
							<code data-trim class="javascript">
const partialApplication = (fn, ...args) =>
(...otherArgs) => {
	return fn.apply(this, 
		Array.prototype.concat.call(...args, ...otherArgs)
	);
}							
							</code>
						</pre>
					</section>
				</section>
				<section>
					<section>
						<h6>Using the partially applied function</h6> 
						<p>Write a function that uses partial application and returns the average of one or more sets.</p>
					</section>
					<section>
						<h6>Solution to Partial Application Problem.</h6>
						<pre>
							<code data-trim class="javascript">
const partialApplication = (fn, ...args) =>
(...otherArgs) => {
	return fn.apply(this, 
		Array.prototype.concat.call(...args, ...otherArgs)
	);
}	

function averageUp(...numbers) {
    return numbers.reduce((prev, curr) => prev + curr, 0) 
		/ numbers.length;
}

function averageMultipleSets(args) {
    return partialApply(averageUp, args)();
}						
							</code>
						</pre>
					</section>
				</section>
        </div>
		<script src="lib/head.min.js"></script>
        <script src="reveal.js"></script>
        <script>			
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,
				transition: 'convex',    
				math: {
					mathjax: 'https://cdn.mathjax.org/mathjax/latest/MathJax.js',
					config: 'TeX-AMS_HTML-full'
				},            
				dependencies: [
					{ 
						src: 'plugins/highlight/highlight.js', 
						async: true, 
						callback: function() { 
							hljs.initHighlightingOnLoad(); 
						} 
					},
					{ 
						src: 'plugins/math/math.js', 
						async: true 
					}
				]
			});
		</script>
    </body>
</html>